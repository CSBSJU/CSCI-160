<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <link href="https://fonts.googleapis.com/css?family=Roboto+Condensed:light" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:light" rel="stylesheet">
    <style>
      * {color: #93a1a1; font-family: "Roboto Condensed", sans-serif;}
      body {background-color: #eee8d5;}
      h2,h3 {color: #073642;}
      a,a:active,a:visited {color: #d33682;}
      pre,kbd,code {font-family: "Roboto Mono", sans-serif; font-size: 85%;}
      kbd {color: #d33682;}
      pre,code {color: #6c71c4;}
    </style>
    <title>Computing with numbers &#8212; a Cannon</title>
  </head>
  
  <body>
    <h2>
      Computing with numbers &#8212; a Cannon
    </h2>

    <p>
      The very first application for the first electronic computer was to
      compute artillery tables for cannons in World War II. In this lab, we'll
      implement a couple of programs that compute a simple version of this
      problem.
    </p>

    <h3>
      Preliminaries
    </h3>

    <p>
      Using a terminal window, copy the directory named <kbd>cannon</kbd> from
      <kbd>/usr/people/classes/CS160/labs</kbd> into your <kbd>CS160</kbd>
      directory. Use the <kbd>tree</kbd> command to verify that the directory
      structure for your local copy of <kbd>cannon</kbd> matches the following:
    </p>

    <pre style="color: #d33682;">
    cannon
    |-- CannonDriver.java
    |-- Cannon.jpg
    |-- Lab.html
    |-- Physics.java
    `-- solution
        |-- CannonDriver.class
        `-- Physics.class
    </pre>

    <h4>
      Introduction to pair programming
    </h4>

    <p>
      In this lab, you will be working in pairs, using a software development
      technique called <em>pair programming</em>. The pair will be divided by
      roles: one person will be the <em>recorder</em> and the other will be the
      <em>developer</em>. The recorder will do all the entry of program code and
      will keep all the files. The developer will be responsible for doing
      things like drawing diagrams, suggesting ideas for solving the problem,
      and watching as the recorder enters the program. <em>Both</em> programmers
      must take part in designing the program and should continuously interact
      as the programming is done. The principal idea is that &#8220;two heads
      are better than one,&#8221; and there is strong research evidence that
      pair programming is a more efficient way to produce working programs than
      having two individuals working independently. Studies have also shown that
      pair programming in introductory programming courses increases learning in
      much the same way. The partners stay in the same roles for the entire lab.
      In the next lab, the same partners will work together but they will
      exchange roles. Note: if you are placed in a trio due to an odd number of
      students in the lab, there is still one recorder; the other two share the
      developer role.
    </p>

    <hr />

    <p>
      For each of the subsequent methods that are not already present, you
      should create the <em>method signature</em> and write the appropriate
      Javadoc comments for the method <b>before</b> writing the method
      implementation. This will help to ensure that you have a clear
      understanding of the purpose of the method you are writing. It will also
      reduce the chance of forgetting to document your method!
    </p>

    <hr />

    <h3>
      Part 1: Some simple numeric computations
    </h3>

    <p>
      Suppose that a cannon ball is shot from a cannon at an angle <em>A</em>,
      as pictured below. The ball will shoot out at that angle and will
      eventually drop to earth some distance away from the starting point. If
      the ball shoots at an initial velocity of
      <em>v</em><sub style="font-size: 50%;">0</sub>, and if the vertical
      acceleration due to gravity <em>g</em> is &#8722;9.80665 meters per second
      per second, then the vertical component of the initial velocity
      <em>v<sub style="font-size: 70%;">vert</sub></em> will be, as shown in the
      diagram below,
      <em>v</em><sub style="font-size: 50%;">0</sub> <em>sin&#8201;A</em>,
      and the horizontal component,
      <em>v<sub style="font-size: 70%;">horiz</sub></em> will be
      <em>v</em><sub style="font-size: 50%;">0</sub> <em>cos&#8201;A</em>.
      The formula for the height of the cannon ball after <em>t</em> seconds,
      assuming no friction will be:
    </p>

    <pre style="font-size: 100%;">
    <em>height(v<sub style="font-size: 50%;">0</sub> , A, t) = v<sub style="font-size: 70%;">vert</sub> t + g&#8201;t<sup style="font-size: 50%;"> 2</sup> &#8260; 2</em></pre>

    <p>
      Similarly, the formula for the horizontal distance the cannon ball has
      moved after <em>t</em> seconds is:
    </p>

    <pre style="font-size: 100%;">
    <em>distance(v<sub style="font-size: 50%;">0</sub> , A, t) = v<sub style="font-size: 70%;">horiz</sub> t</em></pre>

    <p>
      provided that <em>t</em> isn't past the time when the cannonball hits the
      ground.
    </p>

    <p style="text-align: center;">
      <img style="width: 381px; height: 316px;" alt="cannon" src="Cannon.jpg" />
    </p>

    <p>
      Using the supplied <kbd>Physics.java</kbd>, complete the
      <em>height(v<sub style="font-size: 50%;">0</sub> , A, t)</em> method and
      add the <em>distance(v<sub style="font-size: 50%;">0</sub> , A, t)</em>
      method using the formulas above. Note that it uses the variable
      <code>GRAVITY</code> for the constant <em>g</em>. The Java language has
      the following predefined methods that compute trigonometric functions that
      might be useful: <code>sin(double a)</code> and <code>cos(double
      a)</code>. However, these functions require that the angle that is input
    be in radians, so the range of valid angles runs from 0 to &#960;/2 radians,
    which is equivalent to 0 to 90 degrees. The Java language also defines a
    constant variable <code>PI</code>, which is the closest approximation to
    &#960; possible in the <code>double</code> type; you should always use the
    <code>PI</code> variable, rather than your own approximation of &#960;. You
    can use this constant as part of the formula to convert degrees to radians,
    or you can use the <code>toRadians()</code> method, also part of the Java
    language.
    </p>

    <p>
      Do some experimentation to convince yourself that your methods works
      correctly. Add appropriate comments if you have not already done so. Show
      your working methods and code to the lab instructor or TA before moving
      on.
    </p>

    <h3>
      Part 2: Computing artillery data
    </h3>

    <p>
      For a given initial velocity and angle, we are interested, in general, in
      finding out when and where the cannonball hits the ground. With a little
      reflection, we can recognize that the cannon ball is at ground level at
      the value of <em>t</em> that satisfies the equation
      <em>height</em>(<em>v</em><sub style="font-size: 50%;">0</sub>,
      <em>A</em>, <em>t</em>) = 0. We can
      find this value of <em>t</em> by solving the equation:
    </p>

    <pre style="font-size: 100%;">
    <em>v<sub style="font-size: 50%;">0</sub> sin A&#8201;t + g&#8201;t<sup style="font-size: 50%;"> 2</sup> &#8260; 2 = 0</em></pre>

    <p>
      Since this is a quadratic equation, it has two solutions, but one of them
      is <em>t</em> = 0, which clearly isn't the one we want. We can
      eliminate the zero root by dividing both sides of the equation by
      <em>t</em>. Solving the resulting equation for <em>t</em> is easy algebra.
      (Yes, that means you folks need to do a little algebra at this point.)
    </p>

    <p>
      Add a new method <code>timeToHit(v0, A)</code> that computes and returns
      the value of <em>t</em> at which the cannonball hits the ground.
    </p>

    <h3>
      Part 3: Computing an artillery table
    </h3>

    <p>
      Using the supplied <kbd>CannonDriver.java</kbd>, complete the
      <code>main()</code> method. It should get values for <em>v0</em> and
      <em>A</em> from the user and then use a <code>for</code>-loop to print the
      values of <em>t</em>, <em>height</em> and <em>dist</em> in tabular form,
      starting at <em>t</em> = 0.0 and incrementing <em>t</em> by appropriate
      amounts until it gets to the value of <em>t</em> where it hits the ground.
      To do this with equal divisions of 1/20<sup>th</sup>, for example, the
      loop variable ranges from 0 to 20, inclusive; the value of t for each
      iteration will be the loop variable multiplied by the time to hit divided
      by 20.
    </p>

    <p>
      Print the results using the <code>System.out.println()</code> method. You
      can use something like:
    </p>

    <pre>
    System.out.println(String.format("%7.3f   %7.3f   %7.3f", t, h, d));</pre>

    <p>
      where <em>t</em>, <em>h</em> and <em>d</em> are variables for the time,
      height and distance, respectively. The format here allocates seven
      character spaces for each number and three decimal places, with three
      spaces between numbers.
    </p>

    <p>
      Do several tests of your program with different values for the parameters.
      Try an initial velocity of 15, with angles ranging from 10 to 90 degrees.
      (What should happen if the angle is 0?) Repeat a couple of those tests
      with an initial velocity of 30. Is the distance traveled exactly twice
      what it was before? Try to find an angle that consistently maximizes the
      distance traveled, then use that angle with a very high initial velocity
      (say 10000).
    </p>
  </body>
</html>
